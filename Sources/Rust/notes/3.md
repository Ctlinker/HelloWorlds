# Note of Work

## Data types

### Observation

I quote `Every value in Rust is of a certain data type` the `3.1 Data Type`
section, focus on two type of data:

- scalar
- compound

Which I'm yet to fully understand

#### Scalar

I quote
**`A scalar type represents a single value. Rust has five primary scalar types:`**

- integers
- floating-point
- numbers
- Booleans
- characters.

##### Integers

_**Integers come in two flavors: signed and unsigned.**_

_**Signed**_ integers follow the range formula: [ −(2<sup>n − 1</sup>), 2<sup>n
− 1</sup> − 1 ], where n is the number of bits. Examples:

- **i8** — 8-bit signed integer
  - **_<small>[−(2<sup>8−1</sup>), 2<sup>8−1</sup> − 1] = [−128, 127]</small>_**
- **i16** — 16-bit signed integer
  - **_<small>[−(2<sup>16−1</sup>), 2<sup>16−1</sup> − 1] = [−32,768,
    32,767]</small>_**
- **i32** — 32-bit signed integer
  - **_<small>[−(2<sup>32−1</sup>), 2<sup>32−1</sup> − 1] ≈
    [−2.147×10<sup>9</sup>, 2.147×10<sup>9</sup>]</small>_**
- **i64**— 64-bit signed integer
  - **_<small>[−(2<sup>64−1</sup>), 2<sup>64−1</sup> − 1] ≈
    [−9.223×10<sup>18</sup>, 9.223×10<sup>18</sup>]</small>_**
- **i128** — 128-bit signed integer
  - **_<small>[−(2<sup>128−1</sup>), 2<sup>128−1</sup> − 1]</small>_**

> [!NOTE]
>
> Just in case you might be wondering, the `−1` on the positive side exists
> because 0 counts as a positive number. And the `−1` in the expression
> <code>2<sup>n − 1</sup></code> is there because one bit is used to
> differentiate plus and minus, so only `n − 1` bits actually represent the
> number.

_**Unsigned**_ integers, and flows the rule: [0, 2<sup>n</sup> - 1], Examples:

- **u8** — 8-bit unsigned integer
  - [0, 2<sup>8</sup> − 1] = **[0, 255]**
- **u16** — 16-bit unsigned integer
  - [0, 2<sup>16</sup> − 1] = **[0, 65,535]**
- **u32** — 32-bit unsigned integer
  - [0, 2<sup>32</sup> − 1] ≈ **[0, 4.29×10<sup>9</sup>]**
- **u64** — 64-bit unsigned integer
  - [0, 2<sup>64</sup> − 1] ≈ **[0, 1.844×10<sup>19</sup>]**
- **u128** — 128-bit unsigned integer
  - [0, 2<sup>128</sup> − 1]

> [!NOTE]
>
> Here the whole `n` bits are use to represent the number

**isize and usize** — The size depends on your target's computer architecture
(e.g., x86, x64, ARM).

**Integer Overflow**

What happens if I:

```rs
let num: u8 = 256 // as u8 => [0, 255] ? 256 is out
```

As `u8` => `[0, 255]`, `256` is out of range, So what an error will occur ?

**It depends:**

- when using `cargo run` or `compiling-non release`, rust's set of dev specific
  checkup, while caught the error as you trying to assin an out of range value.
- Yet when building for realase, those check are off, resulting in a integer
  overflow.

> - so `256` will bounce back to beginning of the range, so that our `num` is
>   now `0`. had it been `257`, num would be `1`, `258` ? `2`, and so one and so
>   forth

##### Floating Point Number
