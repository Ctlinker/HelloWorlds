# Note of Work

## Data types

### Observation

I quote `Every value in Rust is of a certain data type` the `3.1 Data Type`
section, focus on two type of data:

- scalar
- compound

Which I'm yet to fully understand

#### Scalar

I quote
**`A scalar type represents a single value. Rust has four primary scalar types:`**

- integers
- floating-point numbers
- Booleans
- characters.

##### Integers

_**Integers come in two flavors: signed and unsigned.**_

_**Signed**_ integers follow the range formula: [ −(2<sup>n − 1</sup>), 2<sup>n
− 1</sup> − 1 ], where n is the number of bits. Examples:

- **i8** — 8-bit signed integer
  - **_<small>[−(2<sup>8−1</sup>), 2<sup>8−1</sup> − 1] = [−128, 127]</small>_**
- **i16** — 16-bit signed integer
  - **_<small>[−(2<sup>16−1</sup>), 2<sup>16−1</sup> − 1] = [−32,768,
    32,767]</small>_**
- **i32** — 32-bit signed integer
  - **_<small>[−(2<sup>32−1</sup>), 2<sup>32−1</sup> − 1] ≈
    [−2.147×10<sup>9</sup>, 2.147×10<sup>9</sup>]</small>_**
- **i64**— 64-bit signed integer
  - **_<small>[−(2<sup>64−1</sup>), 2<sup>64−1</sup> − 1] ≈
    [−9.223×10<sup>18</sup>, 9.223×10<sup>18</sup>]</small>_**
- **i128** — 128-bit signed integer
  - **_<small>[−(2<sup>128−1</sup>), 2<sup>128−1</sup> − 1]</small>_**

> [!NOTE]
>
> Just in case you might be wondering, the `−1` on the positive side exists
> because 0 counts as a positive number. And the `−1` in the expression
> <code>2<sup>n − 1</sup></code> is there because one bit is used to
> differentiate plus and minus, so only `n − 1` bits actually represent the
> number.

_**Unsigned**_ integers, and flows the rule: [0, 2<sup>n</sup> - 1], Examples:

- **u8** — 8-bit unsigned integer
  - [0, 2<sup>8</sup> − 1] = **[0, 255]**
- **u16** — 16-bit unsigned integer
  - [0, 2<sup>16</sup> − 1] = **[0, 65,535]**
- **u32** — 32-bit unsigned integer
  - [0, 2<sup>32</sup> − 1] ≈ **[0, 4.29×10<sup>9</sup>]**
- **u64** — 64-bit unsigned integer
  - [0, 2<sup>64</sup> − 1] ≈ **[0, 1.844×10<sup>19</sup>]**
- **u128** — 128-bit unsigned integer
  - [0, 2<sup>128</sup> − 1]

> [!NOTE]
>
> Here the whole `n` bits are use to represent the number

**isize and usize** — The size depends on your target's computer architecture
(e.g., x86, x64, ARM).

**Integer Overflow**

What happens if I:

```rs
let num: u8 = 256 // as u8 => [0, 255] ? 256 is out
```

As `u8` => `[0, 255]`, `256` is out of range, So what an error will occur ?

**It depends:**

- when using `cargo run` or `compiling-non release`, rust's set of dev specific
  checkup, while caught the error as you trying to assin an out of range value.
- Yet when building for realase, those check are off, resulting in a integer
  overflow.

> - so `256` will bounce back to beginning of the range, so that our `num` is
>   now `0`. had it been `257`, num would be `1`, `258` ? `2`, and so one and so
>   forth

**writing integers:**

- binary: `0b1111_0000`
- octal : `0o77`
- hex: `0xff`
- decimal: `98_222` | `98222`
- Byte ( u8 only): `b'A'`

These are all valid way to write integer in rust.

> [!NOTES]
>
> Hum dumb question can binary/hex/oct like num be acted upon with decimal value
> ? eg :
>
> ```rs
> let v1 = 0xff + 1;
> let v2 = 3;
> let v3 = 0xff + v2;
> ```
>
> And if possible what would I see if I tried to print the value ?

#### Floating Point Number

I quote
`Rust has two primitive types for floating-point numbers, which are numbers with decimal
points. Rust’s floating-point types are f32 and f64 , which are 32 bits and 64 bits in size,
respectively. The default type is f64 because on modern CPUs, it’s roughly the same speed
as f32 but is capable of more precision.`

#### Numeric Operation

In a nutshell:

- addition `+`
- subtraction `-`
- multiplication `*`
- division `\`
- remainder `%`

##### Boolean

Specifiable As:

```rs
let t = true;
let f: bool = false;
```

##### The Characters

Rust define character as **String Literal**

```rs
let c = 'z';
let z: char = 'ℤ'; // with explicit type annotation
```

> [!NOTE]
>
> - **These are expect to be inside `'` (single quote)**
> - **Where _String Literals_ em are expected to be inside `"` (double quote)**
>
>> - Also emoji does count as char, (well it may vary due to the used text
>>   encoding, gotta checks on that)

#### Compound Types

I quote **`Compound types can group multiple values into one type`**

Rust as two of primitive those:

- _**Arrays**_
- _**Tuples**_

##### Tuples

In Rust tuples are way of grouping together a set of values with variety of
types:

```rs
let tup: (i32, f64, u8) = (500, 6.4, 1);
```

They have differ from array as they:

- **Have a fixed length in any cases**
- **Can't be indexed**

  ```rs
  // This will `panic`
  let tuple: (str, i8) = ("test", 1);
  print!("tuple {} number {}", tuple[0], tuple[1]);
  ```

To read from a tuple, one need to use either:

- **Destructuring**:

  ```rs
  let tuple: (str, i8) = ("test", 1);
  let (my_str, my_num) = tuple;
  ```

- **Read as Keyof**:

  As rust allow `.x`, where is `x` is a number, as accessible key

  ```rs
  let tuple: (str, i8) = ("test", 1);
  let my_str = tuple.0;
  let my_num = tuple.1;
  ```

> [!NOTE]
>
> I quote :
> `The tuple without any values has a special name, unit. This value and its corresponding type are both written () and represent an empty value or an empty return type. Expressions implicitly return the unit value if they don’t return any other value.`

##### Arrays

Rust Array are extremely specific, They

- **Have a fixed length**
- **Can only contain values of the same type**

**Syntax**:

```rs
let a = [1, 2, 3, 4, 5];
let a: [i32; 5] = [1, 2, 3, 4, 5];
```

**Array Initialization:**

Rust's array comes with a sweat feature to initialize array on the fly:

```rs
let a = [3; 5];
```

I quote
`The array named a will contain 5 elements that will all be set to the value 3 initially. This is the same as writing let a = [3, 3, 3, 3, 3];`

> [!NOTE]
> This begs the question can I ?
>
> ```rs
> let arr = [get_rand(0, 10); 3];
> println!("Test Random Array {}, {}, {}", arr[0], arr[1], arr[2]);
> ```
>
> And if so will i get random values on each slot of the same value on each slot
> ?

**Indexing:**

- Array can be indexed as usual `my_array[x]`, where x is the index.

- Indexed out of the array's length while result in a `panic`

> [!NOTE]
> `my_arr.x` is invalid, as it only apply to tuple s
