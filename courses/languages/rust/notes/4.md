# Note Of Work

## Functions

Note worthy:

- Rust uses `snake_case` as for function and variable names

- We define function as:

  ```rs
  function func_name(some: bool, param: u8) {
    //body
  }
  ```

### Function Body

**Rust is an `expression-based language`, this is an important distinction to
understand**

In general language

- Statements are instructions that perform some action and do not return a value
- Expressions evaluate to literal values

In Rust this distinction is cleaner and way more exploited:

- any expression is considerable as value
- while any statement isn't

So, since in rust such:

```rs
let y = 6;
```

Is a **statement**, things alike

```rs
let x = (let y = 6);
let x = y = 0
```

is impossible, yet rust compensate with this feature of it.

I quote
`Calling a function is an
expression. Calling a macro is an expression. A new scope block created with curly brackets
is an expression`
eg :

```rs
let y = {
    let x = 3;
    x + 1
};
```

Is totally valid rust code where y evaluate to 4

> [!NOTE]
> **BEWARE**, in the exemple code `x + 1` doesn't feature the famous and
> semicolon, it's not an error but intentional.
>
> In Rust
> **`Expressions do not include ending semicolons. If you
add a semicolon to the end of an expression, you turn it into a statement, and it will then not
return a value.`**

### Return Values

**_Rust, is absurdly picky on that_**

- **FUNCTION MUST PRECISE THERE RETURN TYPE**

```rs
fn five() -> i32 {
    5
}
fn plus_one(x: i32) -> i32 {
    x + 1
}
```

- Early return is possible through `return` keyword

> [!NOTE]
>
> The Book doesn't precise, wherever an `union` (or) like return type, So i
> guess/assume error handling may be done through `result` type

## Comments

Note worthy:

- Syntax:

  ```rs
  // your comment
  ```
