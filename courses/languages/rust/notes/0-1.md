# Note of work

## Hello-World

### Summary

The all starter, just print a msg in terminal

```rs
fn main() {
    println!("Well, myself or future self, Hello, world!");
}
```

### Observation

- Rust is alike **`C`**, anything that need to run must be in the **`main`**
  function.
- An Fn succeeded by the **`!`** operator, seems to refer to a built-in fn, yet
  I'm thinking there's more to it, as the docs ref them as **macro**.

  Coming from `nvim` I guess one can define it's own **macro**. But this beg the
  question : What’s the exact distinction between `normal func` and `macro`?

> [!NOTE]
> Always run `cargo run` from the project root — where `Cargo.toml` is.

## Guessing-Game

### Summary

Well make lil guessing game, input a number as guess check it's correct as
simple as that

### v0.0.0

Core idea, just ask for user input

```rs
use std::io;

fn main() {
    println!("Sup, welcome to my lil guessing game");
    println!("Enter a number, I'll tell you if you guessed right");

    let mut guess = String::new();

    io::stdin()
        .read_line(&mut guess)
        .expect("Error, while reading line");

    println!("You guessed: {guess}");
}
```

#### Observation

**variables:**

- **they can be declared with** the **`let`** keyword, **and are immutable** by
  default
- the **`mut`** keyword allow to **create mutable variable**

**assignment:**

There seem to be some sort `pointer` like logic going on in
`.read_line(&mut guess)`

_**How to put this ?**_ In js to assign value is simple as long you're coherent
eg:

```js
let x = 10;
x = 30;
let y = { test: "passed" };
y.test = "failed";
```

Yet here, it's as if they are not reassigning a value to the variable but more
like literally overriding the content of whatever the var itself is pointing to,
or something alike.

**reference:**

They describe **`&`** as a **reference** like operator, hum, I quote :

`A reference, which gives you a way to let multiple parts of your code access one piece of data without needing to copy that data into memory multiple times.`

Hum, In js when passing a non object data to another fn, one does not ref the
original value but somewhat the value it contains.

What they're saying is reading from the original, **Some sort scope injection
?** As the original variable, is not defined in the target fn is scope.

Hum they precise **`& mut` to make the ref mutable**, Hum so, some kind of
**readonly/read-write** data transfer/flow through fn is at play ?

> [!NOTE]
>
> - Question for you, how does `ownership` is managed ? I mean can I propagate
>   read/write auth in a nested fn ?, and if so how could I be sure of data
>   purity ? morphing the original sound like bad idea to me, but even so why
>   did they ? how can they assure that I'm working with the correct data
>   between two procedure ?
> - Another question for ya, what kind of programming does it open ? Being in
>   drowning typescript for quite a while taught me type level programming, the
>   art of making your code work in theory and practice. what surprised me was
>   predicting code coherence like incoherence. but for this the proper term to
>   ref is `ownership` system, it makes me want to think a bit differently from
>   conventional programming, although it can said equivalent to just setting a
>   value modify it in a procedure and updating it's val from the return data, I
>   somewhat feel there's something more to it

**syntax:**

- Rust is a very strict on semicolon, each instruction must be terminated by one
- the keyword `use` is used to reference external library in the code
  - rust expose it's own `standard` (std) library for interacting with the
    computer/machine eg: `the "io" input/output library`

**object-like:**

In the documentation they employ a strange term to describe what in js would be
**`object`**, well everything or nearly everything in js is an object, but well,
they refer there's as **`type`**

eg **`String::new()`** with to me is alike accessing a props of the string obj;
it's by them reference as fn associated to the **`String`** **type**.

Hum something, alike a class, I would want to say yet this vocabulary imply that
to some point `property` are different/distinct from `method` in some sort of
way that I'm yet to understand.

> [!NOTE]
> One thing to ponder, why this **`.read_line()`** is called a method and not an
> associated fn ?

**result-object:**

Hum in nutshell, it seems to be a safe guard, for op that might fail, it goes
back **`Ok`** | **`Err`**, with an **`expect` method to generated custom err
message**

### v0.1.0

Add in a random num generation

```rs
use rand::Rng; // new dependency (rand)
use std::io;

fn main() {
    println!("Sup, welcome to my lil guessing game");

    let secret_number = rand::thread_rng().gen_range(1..=100);

    println!("Enter a number, I'll tell you if you guessed right");

    let mut guess = String::new();

    io::stdin()
        .read_line(&mut guess)
        .expect("Error, while reading line");

    println!("The secret number is: {secret_number}");
    println!("You guessed: {guess}");
}
```

#### Observation

**string-interpolation:**

```rs
let x = 5;
let y = 10;

println!("x = {x} and y + 2 = {}", y + 2);
```

**range-operator:**

for delimiting op in a given range `start..=end` eg `1..=100`

**doc-gen:**

Rust comes in with a nice feature to generate lib you depend on's documentation,
here this case **rand** library to generate random num

```fish
cargo doc --open
```

### v0.2.0

Compare your guess to the real secret

```rs
use std::cmp::Ordering; // comparison library
use rand::Rng;
use std::io;

fn main() {
    println!("Sup, welcome to my lil guessing game");

    let secret_number = rand::thread_rng().gen_range(1..=100);

    println!("Enter a number, I'll tell you if you guessed right");

    let mut guess = String::new();

    io::stdin()
        .read_line(&mut guess)
        .expect("Error, while reading line");

    println!("You guessed: {guess}");

    match guess.cmp(&secret_number) { 
        // meaning compare the value of guess to the value contained in secret number
        Ordering::Less => println!("too small"),
        Ordering::Equal => println!("it's perfect"),
        Ordering::Greater => println!("too big")
    }
}
```

#### Observation

**match-expression:**

hum the simplest way to picture is **an elaborate switch**. from it's
description it seems that **it receive an expression,** and **compare it's
result to a series of values** till founding the correct one. in this case the
vocabulary the employ **`correct arm`**

> [!NOTE]
>
> - This code won't run as rust is as picky as typescript on data types, eg
>   secret number is a number where the guess is a string
> - I seem to understand the term `type` a lil bit more, hum somewhat the
>   imported libs eg `use std::cmp::Ordering;` seems to extends the literal
>   definition/type of entities in the code eg `String::new()` here represent by
>   guess whom now has `.cmp` method

### v0.2.1

Fix, guess is type right before checking on match

```rs
    io::stdin()
        .read_line(&mut guess)
        .expect("Failed to read line");

    let guess: u32 = guess.trim().parse().expect("Please type a number!");

    println!("You guessed: {guess}");
```

This line

```rs
let guess: u32 = guess.trim().parse().expect("Please type a number!");
```

Means: override the guess variable with an immutable var (absence of `mut`) whom
value's type is expected a **32 bit unsigned number** and to it assign it if
possible **`guess.trim().parse()`** whom may or may not be castable a number.

### v0.3.0

```rs
use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    println!("Sup, welcome to my lil guessing game");

    let secret_number = rand::thread_rng().gen_range(1..=100);

    loop {
        println!("Enter a number, I'll tell you if you guessed right");

        let mut guess = String::new();

        io::stdin()
            .read_line(&mut guess)
            .expect("Error, while reading line");

        let guess: u32 = match guess.trim().parse() {
                Ok(num) => num,
                Err(_) => continue
            }

        println!("You guessed: {guess}");

        match guess.cmp(&secret_number) {
            // meaning compare the value of guess to the value contained in secret number
            Ordering::Less => println!("too small"),
            Ordering::Equal => {
                println!("it's perfect");
                break;
            }
            Ordering::Greater => println!("too big"),
        }
    }
}
```

#### Observation

**result-switch:**

This line

```rs
let guess: u32 = match guess.trim().parse() {
    Ok(num) => num,
    Err(_) => continue
}
```

Remember the result object like ? as well it can be matched, as there's two form
of em `Ok`, `Err` respectively wrapping an err or the expected value.

**loop:**

Syntax `loop { ... }`

- loop {} creates an infinite loop.
- `break` and `continue` still apply as usual
