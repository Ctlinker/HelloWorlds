# Notes oo Work

## Loops in Rust

Rust has three kinds of loops:

---

### 1. `loop` Keyword

> _Just run. No questions asked. I'll stop you myself._

The `loop` keyword creates an **infinite loop** that can only be stopped using a
`break` statement — or manually (e.g., `Ctrl+C` in the terminal).

**Syntax:**

```rust
loop {
    if everything_is_fine {
        // keep going forward
    } else if some_err {
        break;
    }
}
```

---

### Assignability

A `loop` is also an **expression** in Rust, meaning it can return a value.

```rust
let mut counter = 0;

let result = loop {
    counter += 1;
    if counter == 10 {
        break counter * 2;
    }
};

println!("The result is {result}");
```

**What's happening here?**

- We declare a mutable variable `counter`.
- We assign the result of a `loop` to the variable `result`.

But is it really a loop being assigned?

Look closer at this line: `break counter * 2;`

The `break` exits the loop and **returns the value** `counter * 2`, which is
what gets assigned to `result`.

And yes, there’s a semicolon at the end — because `let my_var = ...;` is a
**statement**, and all statements in Rust must end with a semicolon.

> [!NOTE]
>
> This is fantastic — but it begs the question: **why is this allowed?**
> Wouldn’t this count as unreachable code in other languages? Is this just my
> JavaScript background messing with me? Also: _does this mean every branch in
> the loop must return a value if we want to assign it?_

---

### Loop Labeling

To avoid confusion in nested loops, Rust allows us to **label** loops so we can
break out of specific ones.

```rust
let mut count = 0;

'counting_up: loop {
    println!("count = {count}");
    let mut remaining = 10;

    loop {
        println!("remaining = {remaining}");

        if remaining == 9 {
            break;
        }

        if count == 2 {
            break 'counting_up;
        }

        remaining -= 1;
    }

    count += 1;
}

println!("End count = {count}");
```

> [!WARNING]
>
> Loop labeling is powerful, but also risky. If you’re not careful, you might
> introduce unexpected behavior by breaking out too early or in the wrong place.

---

### 2. `while` Loops

> _Just run, and ask questions later._

**Syntax:**

```rust
fn main() {
    let mut number = 3;

    while number != 0 {
        println!("{number}!");
        number -= 1;
    }

    println!("LIFTOFF!!!");
}
```

Like in many other programming languages, a `while` loop continues running **as
long as** the condition evaluates to `true`.

---

## Looping Through Collections

> [!NOTE]
>
> Why is the term “collection” used here, instead of just “list” or “array”? —
> Possibly because it's more generic — `Vec`, `HashMap`, `slice`, etc., all fall
> under collections.

---

### Using `while`

```rust
fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut index = 0;

    while index < 5 {
        println!("the value is: {}", a[index]);
        index += 1;
    }
}
```

This is simple, but a bit error-prone:

- You have to manually manage the index.
- There’s potential overhead from constantly checking the condition.
- A mistake in the condition might lead to accessing out-of-bounds values.

> [!NOTE]
>
> If nested correctly, could this pattern be used to **map/remap** values and
> assign them elsewhere?

---

### Using `for...in`

```rust
fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a {
        println!("the value is: {element}");
    }
}
```

Much cleaner and safer than using `while` with a manual index.

---

### Using `for...in` with Ranges

```rust
fn main() {
    for number in (1..4).rev() {
        println!("{number}!");
    }

    println!("LIFTOFF!!!");
}
```

- `(1..4)` is a **range**.
- `..` is the **range operator**, specifying `start..end`, _exclusive_ of the
  end.
- You can reverse a range with `.rev()`.

A few examples:

- `1..5` → 1, 2, 3, 4
- `1..=5` → 1, 2, 3, 4, 5 (inclusive)
- `1..` → all values from 1 to infinity (limited by `isize` or `usize` max)

---

## Summary Thoughts

Rust’s loop system is:

- **Low-level flexible** with `loop`
- **Structured and safe** with `while` and `for`
- **Expression-oriented**, meaning even loops can return values
- **Scope-aware**, letting you escape nested loops precisely

This combination makes rust expressive, but always explicit.
